
CPU의 내부 구성은 크게 CU, ALU, REGISTER로 구분할 수 있다.

![[CPU Block.png]]

# CU(Controll Unit)
제어유닛, ALU, Register 등의 주변 유닛들을 제어하여 메모리부터 기계어 명령을 읽고, 어떤 동작을 해야 하는지 해석하고, 명령을 실행한다.

# ALU(Arithmetic Logic Unit)
연산 유닛, 산술 및 로직 연산을 담당하는 연산 유닛이다. ALU는 하나 또는 두 개의 피연산자(Operand)와 1 개의 출력을 가지는데, +, - 등의 산술 연산과 AND, OR 등의 논리 연산을 할 수 있는 마이크로 연산 로직들을 포함한다. 연산 결과의 상태는 레지스터에 비트로 표시된다.

# REGISTER
CPU는 명령이나 데이터를 메모리에서 읽어와 일을 수행한다. 이 정보를 읽어오기 위한 통신 신호선을 Bus라 하는데, 이 신호선이 길수록 저항과 커패시턴스의 영향으로 신호 지연이 발생해 통신 속도에 제약이 생긴다. 레지스터는 이런 속도의 지연 없이 가장 빨리 접근할 수 있도록 CPU 블록 안에 두어 데이터의 임시저장, 연산 작업 등에 사용하는 일종의 CPU 전용 메모리이다. CPU 외의 다른 로직에서 동작 환경 설정 및 정보 공유, 제어 등을 위한 메모리 블록도 통상 레지스터라 부르지만, 이 부분에서는 CPU의 전용 레지스터이다.

CU와 ALU는 일반 펌웨어를 다룰 때에는 접근하지도 못하고, 접근할 일도 없지만, 일반 레지스터들은 펌웨어에서 **항상 사용**되며 특수 레지스터들은 종종 접근하여 사용하므로 레지스터의 종류와 역할은 알아 두자.

## 일반 목적 레지스터 (General Purpose Register)
R0, R1, R2 ... R9와 같이 [R + 숫자]로 정의 되는 일반 레지스터는 일반 목적 즉 데이터으 ㅣ임시 저장, 함수의 인수, 변수, 연산 결과 저장 등의 일반적인 용도로 사용되는 레지스터로 사용자 프로그램에서도 항상 사용된다.
![[컴파일.png]]

예를 들어, 위 그림과 같이 C 언어로 변수 a에 대해 3을 더하는 산술 연산을 하기를 했다면, C 컴파일러가 일반 목적 레지스터를 사용하는 어셈플리어로 변환해준다.

## 특수 목적 레지스터

|            레지스터 이름             |                                                              용도                                                               |
| :----------------------------: | :---------------------------------------------------------------------------------------------------------------------------: |
|     PC<br>Program Counter      |                                - 다음 실행될 명령어의 메모리 주소 저장<br>- 한 개의 명령 인출이 끝나면 자동으로 다음 명령어 주소 저장                                 |
|   IR<br>Instruction Register   |                                   - PC 주소의 메모리에서 읽어온 명령어 저장<br>- CU는 IR 레지스터의 명령어를 해석하여 수행                                    |
|      LR<br>Link Register       |                                                   - 함수 호출 시 수행 후 복귀될 주소 저장                                                    |
| PSR<br>Program Status Register | - 명령을 수행한 후 연산 결과 등에 대한 CPU 상태 정보 기록<br>- 상태 정보 중 ALU 산술 연산에 대한 결과 비트로는 Overflow, <br>Negative, Zero, Carry, Parity 비트 등이 있다. |
| MAR<br>Memory Address Register |                                           - 메모리 또는 IO로의 읽기/쓰기 동작이 수행될 주소가 저장된 레지스터                                            |
| MBR<br>Memory Buffer Register  |                                             - 메모리 또는 IO에서 읽거나 쓸 데이터가 임시 저장되는 레지스터                                             |
|  SP<br>Stack Pointer Register  |                                                   - 스택의 현재 위치 주소를 저장한 레지스터                                                    |

## Program Counter

CPU가 PCR에 저장되어 있는 메모리 주소에서 명령을 읽어오면, 자동적으로 PC 레지스터의 값은 하나 증가하여 다음 주소를 가리킨다.  프로그램 카운터를 사용자 프로그램에서 직접 접근하여 값을 수정하는 경우는 거의 없지만, 직접 사용하는 예를 들면 OS 시스템의 멀티테스킹 동작이 있다.

멀티테스킹이란, 시간을 분할하여 작은 시간 단위로 쪼개어 테스크(함수)들을 번갈아 가면서 분할된 시간만큼씩 실행시킴으로써 동시의 여러 개의 테스크들이 종작하는 것처럼 보이는 효과를 의미한다.

이 OS 시스템의 멀티테스킹 동작에서는 작은 시간 주기마다 현재 실행하는 메모리 주소를 가리키는 프로그램 카운터에 각 테스크들의 주소를 번갈아 바꾸어 가며 실행 위치를 제어함으로써 구현할 수 있다. 이렇게 프로그램 카운터의 주소를 바꿔주는 행위를 **컨텍스트 스위칭(Context Switching)** 이라고 한다.

## Program Status Register

상태 레지스터는 CPU의 현재 상태 또는 ALU의 연산 결과 등 정보의 상태를 비트형태로 표시하는 레지스터이다.
다음은 상태 레지스터의 대표적인 플래그 비트들의 예이다.

![[PSR.png]]

## Stack Pointer

Stack은 데이털르 저장하고 복원하는 등의 동작에 사용되는 메모리 저장 구조로 데이터를 저장하는 동작을 PUSH, 데이터를 인출하는 동작을 POP이라 한다. 이들은 실제 어셈블리어의 명령어이기도 한다.

Stack은 마지막에 저장된 데이터가 맨 처음 나온다 하여 LIFO(Last In First Out) 구조라 하며, 일반 함수의 호출과 실행에서도 사용되며, 인터럽트 핸들러에서의 정보 저장/복원 등 다양한 용도로 사용되므로 동작에 대해서 알아야 할 필요가 있다.

다만, 여기선 이미 Stack 자료구조에 대해 빠삭하게 공부한 바 있으므로 생략하겠다.

![[Stack Pointer.png]]