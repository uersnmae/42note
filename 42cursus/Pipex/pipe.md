        운영체제(Unix/Linux 계열)의 *프로세서 간 통신*(InterProcess Communication)에 사용되는 **파이프**에 대해 실습하는 과제

### IPC (InterProcess Communication) ###
주로 한 프로세스에서 다른 프로세스로 데이터를 전달할 때 사용된다.

## 기본 개념

1. **단방향 통신**
    - 파이프는 보통 한쪽에서 쓰기, 다른 한쪽에서 읽기만 가능한 **Half-Duplex**구조이다.
    - 양방향 통신이 필요하다면 파이프를 두 개 만들거나 다른 IPC 기법([소켓], [메시지 큐] 등)을 병행 사용한다.
2. 프로세스 간의 데이터 전달
    - 파이프를 생성하면 커널이 관리하는 **임시 버퍼(큐)** 가 마련된다.
    - 쓰는 쪽 프로세스가 `write()` 호출을 통해 데이터를 버퍼에 쓰고, 읽는 쪽 프로세스는 `read()`호출로 버퍼에서 데이터를 가져간다.
3. [부모-자식 프로세스] 사용이 일반적
    - 익명 파이프(Anonymous Pipe)는 파이프를 연 뒤 보통 `fork()`를 통해 자식 프로세스를 만들고, 각각의 파일 디스크립터를 적절히 닫거나 표준 입출력(STDIN / STDOUT)에 연결해 사용한다.
    - 대표적인 예: 쉘에서 `ls -l | grep txt`를 실행할 경우, 쉘이 내부적으로 파이프를 생성한 뒤,
        - 프로세스 A(`ls -l`) -> 파이프에 출력
        - 프로세스 B(`grep txt`) -> 파이프에서 입력
        하는 식으로 동작한다.

# 1. 익명 파이프(Anonymous Pipe)

익명 파이프는 보통 커맨드 라인에서 `|` 로 표현된다. 예를 들어,
```
ls -l | grep txt
```

라고 한다면, `ls -l`의 출력(표준 출력)이 파이프 `|` 를 통해 `grep txt`의 입력(표준 입력)으로 전달되는 방식이다.

## 생성 및 사용

- C/C++ 등에서 `pipe(int fds[2])` 시스템 호출로 두 개의 파일 디스크립터를 얻는다.
    - `fds[0]` -> 읽기 전용(읽기 끝단, read end)
    - `fds[1]` -> 쓰기 전용(쓰기 끝단, write end)
- 이후 `fork()`로 자식 프로세스를 만들고, 각 프로세스에서 필요 없는 끝을 `close()` 한 뒤, 유효한 끝을 표준입출력에 `dup2()`로 연결해서 사용한다.
- 쉘에서 `|` 기호를 쓸 때 바로 이 익명 파이프 방식이 내부적으로 사용된다.
## 특징

- [ ] **단방향** 통신: 한 파이프는 기본적으로 한쪽에서 쓰고(Write), 다른 한쪽에서 읽는(Read) 구조(쓰기 -> 읽기)이다.
- [부모-자식 관계에서 주로 사용: 익명 파이프는 부모-자식(또는 형제 프로세스가 공통 부모를 둠) 관계에서만 사용 가능하며, 명시적인 상관관계가 없는 프로세스끼리는 직접 사용하기 어렵다.
- **임시적**: 파일 시스템에 이름이 없는(익명) 상태이며 파이프의 존재는 커널 내부에서만 관리된다. 파이프를 만든 부모-자식 프로세스들이 종료되면 파이프도 사라진다.

## 장점 & 단점

- 장점: 설정이 간단하고 빠른 프로세스 간 통식 방식, 매우 쉽게 데이터 흐름을 구성할 수 있고 쉘 스크립트나 커맨드라인에서 매우 쉽게 사용 가능
- 단점: 이름이 없고 부모-자식 간에만 연결되므로 같은 부모를 둔(혹은 직접적으로 연결된) 프로세스들끼리만 사용 가능, 즉 완전히 독립적인 프로세스끼리의 통신에는 부적합하다. 단방향이므로 양방향 통신을 위해선 파이프 2개를 만들어야 한다.


# 2. 명명된 파이프(Named Pipe, FIFO)

익명 파이프와는 달리 **파일시스템에 이름(경로)이 있는 파이프**를 말한다. 유닉스 계열에서는 FIFO파일이라고 부르기도 한다.
## 생성 및 사용

- 유닉스 / 리눅스 계열에서 `mkfifo` 명령(또는 `mkfifo()` 시스템 콜)으로 파일 시스템에 특별한 파일(장치 파일 형태)이 생성된다.
- `open("mypipe", O_WRONLY)`, `open("mypipe", O_RDONLY)`처럼 쓰기/읽기 방식으로 열어서 사용하면, 서로 다른 프로세스 간에 데이터를 주고받을 수 있다.
## 특징

- 파일 시스템상의 경로 존재: `mypipe` 같은 이름이 있으며, 이 이름을 통해 다수의 프로세스가 서로 시점을 달리해도 읽고 쓸 수 있다.
- 단방향: FIFO도 기본적으로 한쪽에서 쓰고 다른 한쪽에서 읽는 구조이다.
- 독립적인 프로세스 간 통신 가능: 파이프 생성과 프로세스 생성이 직접 연결되지 않아도 되므로, 관련 없는(부모-자식 관계가 아닌) 프로세스라도 해당 파일 경로를 통해 통신할 수 있다.

## 장점 & 단점

- 장점: 프로세스의 생성 시점과 무관하게 파일 시스템에 있는 파이프 이름으로 통신할 수 있어 활용 범위가 넓다.
- 단점: 단방향이며, 파일 시스템에 별도의 FIFO 파일을 관리해야 한다. (권한, 위치 등 관리가 필요)

## 파이프의 동작 방식 요약

1. **생성**: (익명 파이프의 경우) 주로 `pipe()` 시스템 호출로 생성, (명명된 파이프의 경우) `mkfifo` 등으로 파일 시스템에 생성.
2. **연결**: 프로세스는 `fork()`를 통해 자식 프로세스를 만들고, 자식의 표준 입출력을 파이프의 읽기/쓰기 끝단으로 리다이렉션(dup2) 처리.
3. **읽기/쓰기**: 한 프로세스(쓰기 측)가 `write()`를 통해 데이터를 쓰면, 다른 프로세스(읽기 측)는 `read()`로 데이터를 받음. 파이프 내부는 운영체제가 관리하는 버퍼로 이루어지며, 버퍼가 가특 차면 쓰기 측은 잠시 대기하고, 버퍼가 비면 계속 쓸수 있음.


# 파이프의 동작 방식과 원리

## 커널 버퍼(Circular Buffer)

- 파이프 생성 시, 운영체제 커널은 **일정 크기**의 고정 버퍼(서큘러 큐)를 할당한다.
- 쓰기(write) 호출을 하면 버퍼가 가득 차지 않은 이상 데이터를 쓸 수 있고, 버퍼가 가득 차면 쓰는 프로세스는 잠시 **블록(block)** 상태가 된다. (기본 블로킹 I/O 동작).
- 읽기(read) 호출을 하면 버퍼에 데이터가 있으면 바로 읽고, 없으면 읽는 프로세스가 블록되어 대기한다.

## [블로킹] vs [논블로킹] I/O

- 블로킹 I/O가 기본 동작이며, 파이프 버퍼에 빈 공간(또는 데이터)이 없으면 `write()`(또는 `read()`)가 대기 상태가 된다.
- `fcntl()`이나 `ioctl()` 등을 통해 **논블로킹 모드**(O_NONBLOCK)로 설정할 수 있으며, 이 경우 버퍼가 꽉 차 있으면 write()가 -1(에러) 반환, 버퍼에 데이터가 없으면 `read()`가 -1을 반환한다.
    - 논블로킹 모드에서는 `select()`, `poll()`, `epoll()` 같은 시스템 콜과 함께 사용해 이벤트 기반 I/O를 구현할 수 있다.

## 종료 및 EOF(End Of File) 처리

- 쓰는 쪽 프로세스가 모두 `close()`를 해버리면, 읽는 쪽 프로세스에서 `read()`의 결과가 0(EOF)이 된다. (데이터가 더 이상 안 들어옴)
- 마찬가지로 읽는 쪽 프로세스가 모두 종료(또는 해당 파이프를 `close()`하면), 쓰는 쪽에서 `write()`가 에러(SIGPIPE 신호) 또는 -1을 반환하게 된다.


# 파이프 사용 시나리오

1. 쉘 파이프라인
    - 명령어 라인에서 `|` 기호 사용. 예) `cat file | grep keyword`
    - 쉘이 내부적으로 `pipe()` -> `fork()` -> `dup2()`(표준입출력 재지정) -> `exec()`를 통해 두 프로세스의 표준출력과 표준입력을 파이프에 연결한다.
2. 프로그램 내에서 파이프 사용
    - C나 파이썬, 자바 등에서 파이프를 만들어 부모-자식 프로세스 간 통신에 사용한다.
    - 예: 서버 프로세스가 자식 프로세스를 생성하여 일부 작업을 맡기고, 그 결과를 파이프로 받아 본인이 후속 처리를 수행하는 구조.
3. 이벤트 처리 / 스트리밍
    - **명명된 파이프(FIFO)** 를 이용해 한 프로세스는 계속해서 데이터를 쓰고, 다른 프로세스는 실시간으로 읽어가며 처리하는 형태로 사용하기도 한다.



# 파이프와 다른 IPC 메커니즘

1. 소켓(Socket)
    - 로컬 시스템(UNIX 도메인 소켓)뿐 아니라 네트워크를 통한 원격 통신도 가능.
    - 데이터 경계(스트림 소켓 vs 메시지 소켓)나 프로토콜(TCP / UDP) 선택 등이 가능.
    - 구현이 조금 더 복잡하지만, 유연성과 확장성이 뛰어남.
2. 공유 메모리(Shared Memory)
    - 프로세스들이 메모리 영역을 공유하여 대량의 데이터를 매우 빠르게 주고 받을 수 있음
    - 대신 **동기화 기법**(세마포어, 뮤텍스 등)을 직접 설계해야함
3. 메시지 큐(Message Queue)
    - 커널이 메시지 단위를 구분하여 관리.
    - 파이프보다 유연한 면이 있으나, 별도의 메시지 식별·관리 코드가 필요.
4. 시그널(Signal)
    - 간단한 이벤트(인터럽트 발생) 알림 수준. 큰 데이터 전달에는 부적합.