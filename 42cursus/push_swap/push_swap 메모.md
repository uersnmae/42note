
# push_swap subject 정리

## Objectives

[[complexity]] 란? 대충 직흥적으로 생각하면 '얼마나 복잡한지'에 대한 척도를 나타낸다. Computer Science에서는 대표적으로 '시간 복잡도'와 '공간 복잡도'가 있다.

위키피디아 문서에 의하면, **어떤 알고리즘이 입력값을 처리하는데 거치는 단계**를 **시간 복잡도(time complexity)** 라고 하고, 그 알고리즘이 차지하는 저장공간의 정도를 **공간 복잡도(space complexity)** 라고 한다.  즉 다음과 같이 정리할 수 있다.

- **시간 복잡도**: 알고리즘이 실행되는 데 걸리는 시간을 입력 크기에 따라 평가하는 척도, 주로 알고리즘의 연산횟구와 관련이 있다.
- **공간 복잡도**: 알고리즘이 실행되는 동안 필요한 메모리 양을 평가한느 척도, 입력 데이터와 추가적으로 필요한 저장 공간에 따라 결정된다.

이번 과제에서는 C 언어와 기본적인 알고리즘을 활용하여 그 개념을 습득하는 것이 주된 목표이다.

궁극적인 목표는 '값의 정리'인데 단순히 어떤 값들을 오름차순, 내림차순으로 하고자 하는 것은 꽤 단순하지만, '가장 빠른 방법을 찾아라'는 건 단순하지 않다. 이번 과제에서는 이런 것들을 생각해보는 것이 중점이 될 듯 하다.

## Mandatory Part

### 규칙

- 두 개의 [[스택]] , **a**와 **b**를 가지고 시작한다.
- 시작할 때
	- **a**는 무작위한 양의 음수, 양수를 가지고 있고 이 값들은 복사될 수 없다.
	-  **b**는 비어 있다.
- **a**를 오름차순으로 정렬하는 것이 목표이다. 다음의 명령어를 선택 및 조합하여 수행한다:
	- sa (swap a): **a**의 top에서부터 2 개의 값들의 위치를 바꾼다. 값이 없거나 빈 스택이라면 아무것도 하지 않는다.
	- sb (swap b): **b**의 top에서부터 2 개의 값들의 위치를 바꾼다. 값이 없거나 빈 스택이라면 아무것도 하지 않는다.
	- ss: sa와 sb를 함께 수행한다.
	- pa (push a): **b**의 top에서 첫 번째 값을 가져와 **a**의 top에 넣는다. **b**가 비어 있다면 아무 것도 하지 않는다.
	- pb (push b): **a**의 top에서 첫 번째 값을 가져와 **b**의 top에 넣는다. **a**가 비어 있다면 아무 것도 하지 않는다.
	 - ra (rotate a): **a**의 모든 값들을 위로 한 칸 올린다. 첫 번째 요소는 맨 마지막으로 내려간다.
	 - rb (rotate b): **b**의 모든 값들을 위로 한 칸 올린다. 첫 번째 요소는 맨 마지막으로 내려간다.
	 - rr: ra와 rb를 함께 수행한다.
	 - rra (reverse rotate a): **a**의 모든 값들을 한 칸 내린다. 마지막 값이 맨 위로 올라온다.
	 - rrb (reverse rotate b): **b**의 모든 값들을 한 칸 내린다. 마지막 값이 맨 위로 올라온다.
	 - rrr: rra와 rrb를 함께 수행한다.

이 명령어들을 이용해 오름차순으로 정렬하면 된다!

# Nov 27, 2024

문득 든 생각으론, 정렬 알고리즘을 구현하고 연습하는 것도 중요하지만, 이 push_swap이란 과제의 요구사항에 맞춰서 **어떤 정렬이든지 수행할 수 있는가**가 중요한 것 같다.

기본적인 명령어와 자료구조의 구현이 끝났으니, 아래와 같은 단계에 맞춰서 과제를 수행해보자

1. 연결 리스트의 버블 정렬 (내가 버블 정렬 밖에 모르니까)
2. push_swap 에서의 버블 정렬 (어차피 과제에서 구현해야하니까)
3. 버블 정렬보다 더 빠른 정렬로 1번부터 다시 시작

이렇게 하는게 중요할 듯 하다.

리스트의 정렬에 있어서, 노드 자체를 정렬하는게 좋을지, 아니면 노드의 데이터만 정렬하는게 좋을지 이게 참 의문이다.

본능적으로는 노드 자체를 정렬하는게 옳다라고 외치고 있는데... 해야 하나? 싶으면 하라고 했으니 노드 자체를 정렬해보자

싱글 링크드 리스트로 한 번 도전해보자