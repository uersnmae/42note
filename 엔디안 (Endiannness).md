멀티바이트로 이뤄진 데이터를 메모리에 저장할 때, **바이트가 어떤 순서대로 배치되는지를 나타내는 개념**

1. 리틀 엔디안(Little-endian)
    - 데이터를 저장할 때 데이터의 LSB부터 메모리의 가장 앞쪽(낮은 주소)부터 배치
    - 예: 정수 0x11223344를 리틀 엔디안으로 메모리에 저장하면 메모리상에는 44 33 22 11 순으로 나타남.
    - x86(인텔, AMD) 계열 프로세서가 대표적인 리틀 엔디안 아키텍쳐
2. 빅 엔디안(Big-endian)
    - 데이터를 저장할 때 데이터의 MSB부터 메모리의 가장 앞쪽(낮은 주소)부터 배치
    - 예: 정수 0x11223344를 빅 엔디안으로 메모리에 저장하면 메모리상에는 11 22 33 44 순으로 나타남.
    - 네트워크 프로토콜(IP 패킷 등)이 주로 빅 엔디안 방식을 사용

이를 검증하기 위해 다음과 같은 코드가 쓰인다.

```c
int a = 0x11223344;

if (((unsigned char *)&a)[0] == 0x11) // 첫 바이트가 0x11이면 빅 엔디안!!
    local_endian = 1;
else
    local_endian = 0;

/* 위의 코드를 함수로 만들면 */
int is_big_endian()
{
    uint16_t num = 0x0102;
    uint8_t *ptr = (uint8_t *)&num;
    return (ptr[0] == 0x01);    // 문자열 ptr의 첫 바이트가 0x01이면 빅 엔디안
}
// 32비트 데이터의 바이트 순서를 반전시키는 함수
uint32_t endian_decoding(uint32_t val)
{
    return ((val & 0xFF) << 24) |         // 하위 바이트를 상위 바이트 위치로
            ((val & 0xFF00) << 8) |       // 두 번째 바이트를 두 번째 상위 위치로
            ((val & 0xFF0000) >> 8) |     // 세 번째 바이트를 두 번째 하위 위치로
            ((val & 0xFF000000) >> 24);   // 상위 바이트를 하위 바이트 위치로
}
```

그래픽 데이터를 다룰 때, 특히 이미지의 픽셀 정보나 색상 값이 메모리에 저장되는 순서에 크게 의존한다. 때문에 다양한 시스템에서 문제 없이 작동하기 위해선 필수적인 초기화 과정이다!