이 문서에서는 GPT, Gemini 등 LLM의 도움을 받아 예제를 작성하면서 본인이 느끼고, 얻은 것들을 정리하고자 한다.

# 내가 뭘 하려고 하는가?

제일 먼저 중요한 점은... 보드에서 내가 어떤 부분을 제어하려고 하는지를 파악하는게 가장 중요한 것 같다. 예를 들어, LD2를 토글하고 싶다고 한다면 이 녀석의 진명을 알아야지만 접근이 가능하고, 매핑이 어떻게 되어있는지 파악할 수 가 있기 때문이다.

하지만 이를 알고 나서도, 이게 GPIO의 어떤 그룹인지, 어떤 레지스터를 초기화해야하는지를 알아도 막상 해보면 잘 안된다. 바로 GPIO를 먼저 건드는게 아니고 RCC, Reset Clock Controller로 먼저 "이 주변 장치들 쓸거니까 준비시켜놔~" 라고 먼저 알려줘야지만 의도한대로 우리가 쓸 수 있기 때문이다.

때문에 지금까지의 순서를 쭉 나열해보자면

1. 뭘 할 건지
2. 그게 어디 있는지
3. 걔를 준비하려면 어떻게 해야하는지

이렇게 세 단계가 아무래도 제일 공통적인 흐름인 것 같다.

예를 들어

```c
#include "stm32f411xe.h"

void delay(volatile uint32_t count) {
	while (count--);
}

int main(void) {
	// 1 << 0 for GPIOA, 1 << 2 for GPIOC
	RCC->AHB1ENR |= (1 << 0) | (1 << 2);

	GPIOA->MODER &= ~(0b11 << 10); /* clear bits */
	GPIOA->MODER |=  (0b01 << 10); /* set output mode */

	GPIOC->MODER &= ~(0b11 << 26); /* clear bits, set input mode */

	while (1) {
		if ((GPIOC->IDR & (1 << 13)) == 0) {
			GPIOA->BSRR = (1 << 5);
		} else {
			GPIOA->BSRR = (1 << (5 + 16));
		}
	}
	return 0;
}

```

와 같은 코드를 작성했다.

GPIOA, GPIOC를 사용해야하기 때문에 RCC의 AHB1ENR에서 LSB, 세 번째 비트를 켜주고
GPIOA와 GPIOC를 각각 input, output mode로 설정해준다 이 모든 것들은 놀랍게도(당연하지만) 레퍼런스 메뉴얼에 적혀져 있다!!!

그리고 GPIOC가 데이터를 input하므로 Input Data Register의 값을 읽어와 조건문으로 설정한다

아마 나머지 페리페럴들을 다루는 것도 이와 비슷하리라 생각한다! 당장 떠오르는 건 PWM, UART 같은 애들인데 얘네들부턴 클락을 활용해야하기 때문에 내부 클락에 대해서 먼저 공부를 해야겠다!!


지금 막 쓰면서도 맨 처음에 생각한 저 세 단계로 가지 않았는가? 와!